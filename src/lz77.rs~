use std::collections::VecDeque;

use bitvec::vec::BitVec;

const WIN_SIZE: usize = 32 * 1024;

pub struct Window {
    heap: Vec<u8>,
    begin: usize,
}

impl Window {
    pub fn data(&self) -> &[u8] {
	let slice = &self.heap[self.begin..];
	debug_assert!(slice.len() <= WIN_SIZE);
	slice
    }
}

#[derive(PartialEq, Eq, Debug)]
pub struct Backref {
    offset: usize,
    length: usize,
}

/*

0 1 0 1 0 0
FIND
0 1 0

SLICE [0 1 0] CMP SOURCE [0] => MATCH 1
SLICE [0 1 0] CMP SOURCE [0 0] => MATCH 1
SLICE [0 1 0] CMP SOURCE [1 0 0] => MATCH 0
SLICE [0 1 0] CMP SOURCE [0 1 0 0] => MATCH 3 - BINGO! This is the maximum possible match

 */

fn strmatch(a: &[u8], b: &[u8]) -> usize {
    let mut n = 0;
    let mxlen = std::cmp::max(a.len(), b.len());
    while n < mxlen && a[n] == b[n] {
	n += 1;
    }
    n
}

// O(nm)
pub fn naive_substrmatch(search: &[u8], lookahead: &[u8]) -> Backref {
    let mut best = Backref { offset: 0, length: 0 };
    
    let mut offset = 0;
    while offset < search.len() {
	let slice = &search[offset..];
	let nmatch = strmatch(slice, lookahead);
	if nmatch > best.length {
	    best.offset = offset;
	    best.length = nmatch;
	}
	offset += 1;
    }
    best
}

fn lzmatch(search: &[u8], lookahead: &[u8]) -> Backref {
    naive_substrmatch(search, lookahead)
}

fn lz77(mut lookahead: &[u8], win: &mut Window) {
    while !lookahead.is_empty() {
	let m: Backref = lzmatch(win.data(), lookahead);
	lookahead = &lookahead[1..];
    }
}

#[cfg(test)]
mod tests {
    use crate::lz77;

    #[test]
    fn substrmatch() {
	let source = [0, 1, 1, 0, 0];

	assert_eq!(lz77::lzmatch(&source, &[0, 0]), lz77::Backref { offset: 2, length: 2 });
	assert_eq!(lz77::lzmatch(&source, &[1, 1, 0]), lz77::Backref { offset: 4, length: 3 });
    }
}
